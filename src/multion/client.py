# This file was auto-generated by Fern from our API Definition.

import os
import typing

import httpx

from multion.base_client import AsyncBaseMultiOn, BaseMultiOn
from multion.environment import MultiOnEnvironment
from multion.sessions.wrapped_client import WrappedAsyncSessionsClient, WrappedSessionsClient
from .core.request_options import RequestOptions
from .types.optional_params import OptionalParams

import agentops
from agentops import ActionEvent, LLMEvent, ErrorEvent
import os


# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class MultiOn(BaseMultiOn):
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: MultiOnEnvironment. The environment to use for requests from the client. from .environment import MultiOnEnvironment

                                           Defaults to MultiOnEnvironment.DEFAULT

        - api_key: typing.Optional[str].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

        - follow_redirects: typing.Optional[bool]. Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

        - httpx_client: typing.Optional[httpx.Client]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from multion.client import MultiOn

    client = MultiOn(
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MultiOnEnvironment = MultiOnEnvironment.DEFAULT,
        api_key: typing.Optional[str] = os.getenv("MULTION_API_KEY"),
        agentops_api_key: typing.Optional[str] = os.getenv("AGENTOPS_API_KEY"),
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        super().__init__(
            base_url=base_url,
            environment=environment,
            api_key=api_key,
            timeout=timeout,
            follow_redirects=follow_redirects,
            httpx_client=httpx_client,
        )
        self.sessions = WrappedSessionsClient(client_wrapper=self._client_wrapper)
        if agentops_api_key is not None:
            agentops.init(api_key=agentops_api_key, auto_start_session=False) #TODO: Add parent key

    def browse(
        self,
        *,
        cmd: str,
        url: typing.Optional[str] = OMIT,
        local: typing.Optional[bool] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        include_screenshot: typing.Optional[bool] = OMIT,
        optional_params: typing.Optional[OptionalParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ):
        agentops.start_session(tags=["multion-sdk"])
        params = {"cmd": cmd}
        if url is not OMIT:
            params["url"] = url
        if local is not OMIT:
            params["local"] = local
        if session_id is not OMIT:
            params["session_id"] = session_id
        if max_steps is not OMIT:
            params["max_steps"] = max_steps
        if optional_params is not OMIT:
            params["optional_params"] = optional_params.json()
        if request_options is not None:
            params["request_options"] = request_options
        action_event = ActionEvent(params=params)
        llm_event = LLMEvent()
        try:
            browse_response = super().browse(cmd=cmd, url=url, local=local, session_id=session_id, max_steps=max_steps, include_screenshot=include_screenshot, optional_params=optional_params, request_options=request_options)
            action_event.returns = browse_response.dict()
            action_event.screenshot = browse_response.screenshot
            llm_event.prompt = browse_response.message
            agentops.record(action_event)
            agentops.record(llm_event)
            return browse_response
        except Exception as e:
            error_event = ErrorEvent(trigger_event=action_event, exception=e)
            agentops.record(error_event)
            raise e

class AsyncMultiOn(AsyncBaseMultiOn):
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: MultiOnEnvironment. The environment to use for requests from the client. from .environment import MultiOnEnvironment

                                           Defaults to MultiOnEnvironment.DEFAULT

        - api_key: typing.Optional[str].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds, unless a custom httpx client is used, in which case a default is not set.

        - follow_redirects: typing.Optional[bool]. Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

        - httpx_client: typing.Optional[httpx.AsyncClient]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from multion.client import AsyncMultiOn

    client = AsyncMultiOn(
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MultiOnEnvironment = MultiOnEnvironment.DEFAULT,
        api_key: typing.Optional[str] = os.getenv("MULTION_API_KEY"),
        agentops_api_key: typing.Optional[str] = os.getenv("AGENTOPS_API_KEY"),
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        super().__init__(
            base_url=base_url,
            environment=environment,
            api_key=api_key,
            timeout=timeout,
            follow_redirects=follow_redirects,
            httpx_client=httpx_client,
        )
        self.sessions = WrappedAsyncSessionsClient(client_wrapper=self._client_wrapper)
        if agentops_api_key is not None:
            agentops.init(api_key=agentops_api_key, auto_start_session=False)  #TODO: Add parent key

    async def browse(
        self,
        *,
        cmd: str,
        url: typing.Optional[str] = OMIT,
        local: typing.Optional[bool] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        include_screenshot: typing.Optional[bool] = OMIT,
        optional_params: typing.Optional[OptionalParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ):
        agentops.start_session(tags=["multion-sdk"])
        params = {"cmd": cmd}
        if url is not OMIT:
            params["url"] = url
        if local is not OMIT:
            params["local"] = local
        if session_id is not OMIT:
            params["session_id"] = session_id
        if max_steps is not OMIT:
            params["max_steps"] = max_steps
        if optional_params is not OMIT:
            params["optional_params"] = optional_params.json()
        if request_options is not None:
            params["request_options"] = request_options
        action_event = ActionEvent(params=params)
        try:
            browse_response = super().browse(cmd=cmd, url=url, local=local, session_id=session_id, max_steps=max_steps, include_screenshot=include_screenshot, optional_params=optional_params, request_options=request_options)
            action_event.returns = browse_response.dict()
            action_event.screenshot = browse_response.screenshot
            agentops.record(action_event)
            return browse_response
        except Exception as e:
            error_event = ErrorEvent(trigger_event=action_event, exception=e)
            agentops.record(error_event)
            raise e